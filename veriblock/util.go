package veriblock

const atomicPerCoin = 1e8

func AtomicToCoin(sat int64) float64 {
	return float64(sat) / float64(atomicPerCoin)
}

func CoinToAtomic(coin float64) int64 {
	return int64(float64(atomicPerCoin) * coin)
}

var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
var alphabetMap = [256]byte{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 9, 10, 11, 12, 13, 14, 15, 16, 0xff, 17, 18, 19, 20, 21, 0xff,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 0xff, 44, 45, 46,
	47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

// EncodeBase58 translated from https://bitcoin.stackexchange.com/a/76485
func EncodeBase58(b []byte) string {
	digits := make([]byte, len(b)*137/100+1)
	digitsLen := 1
	for i := 0; i < len(b); i++ {
		carry := uint64(b[i])
		for j := 0; j < digitsLen; j++ {
			carry += uint64(digits[j]) << 8
			digits[j] = byte(carry % 58)
			carry /= 58
		}
		for carry > 0 {
			digits[digitsLen] = byte(carry % 58)
			digitsLen++
			carry /= 58
		}
	}
	resultLen := 0
	result := make([]byte, len(b)*137/100+1)
	for resultLen < len(b) && b[resultLen] == 0 {
		result[resultLen] = '1'
		resultLen++
	}
	for i := 0; i < digitsLen; i++ {
		result[resultLen+i] = alphabet[digits[digitsLen-1-i]]
	}
	return string(result[:digitsLen+resultLen])
}

func DecodeBase58(b58 string) []byte {
	result := make([]byte, len(b58)*2)
	resultLen := 1
	for i := 0; i < len(b58); i++ {
		carry := uint64(alphabetMap[b58[i]])
		if carry == 0xff {
			return nil
		}
		for j := 0; j < resultLen; j++ {
			carry += uint64(result[j]) * 58
			result[j] = byte(carry & 0xff)
			carry = carry >> 8
		}
		for carry > 0 {
			result[resultLen] = byte(carry & 0xff)
			resultLen++
			carry = carry >> 8
		}
	}
	for i := 0; i < len(b58) && b58[i] == '1'; i++ {
		result[resultLen] = 0
		resultLen++
	}
	z := (resultLen >> 1) + (resultLen & 1)
	for i := resultLen - 1; i >= z; i-- {
		result[i], result[resultLen-i-1] = result[resultLen-i-1], result[i]
	}
	return result[:resultLen]
}
